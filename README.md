# That time I got reincarnated as a document; A blueprint to Dan

Hi, I'm Dan. 
TL;DR; love the details, not so much being bogged down in them. Quality and reliability are as first-class citizens as the software itself!

## Understanding
I am very detail-oriented, and want to know how and why something does things, rather than just being satisfied with what it does. Same applies for building software; I think understanding why we have done something this way over another, and how it works at the lowest level, are some of the most important things to understand how to best iterate on something, or reinvent it.

When faced with an unknown, I am scientific. Start with a hypothesis and see if the data supports it, use feedback and numbers to choose a path forward over anecdotes and vibes, I do love a good vibe though.

## Discussing
I think and read faster than I talk or write, so being prepared for discussions helps me greatly, and I find supplemental documentation and additional resources really helpful before discussions.

I love more asynchronous forms of discussion. Every use case has multiple edge cases, and sometimes this is hard to capture in a linear discussion, and so I love collaborative requirements documents, silent meetings, and comment threads.

If a conversation was well worth having, it should be written down! So many great ideas and important pieces of context are lost in people's heads, and new people should always be able to understand how something works and its historical context. Tickets go across a board and into the void, if everything about how something works only exists in acceptance criteria on a ticket, then I hope it's something I don't have to touch more than once.

## Building
Pragmatism first. What can we do given the constraints, and what is the most important functionality to deliver, and which edge cases pose the biggest risk. A MoSCoW list composed entirely of must haves is one of my least favourite things.

Try new things, doing something is not always a good reason to keep doing it. PoC'ing new and exciting technology helps continuously improve projects, and also makes working on them exciting. Other side of the coin, always be wary of change for change's sake, we all want to leave our marks on things and have favourite languages and tools, but sometimes other ones are just fine too.

## Failure
People don't fail, processes do. Blaming individuals or others doesn't prevent bad things from happening a second time.

## Testing
The best test is written before what it tests, and the best bug is found before something is built! The more people involved in requirements and planning, the more certain we can be that we're building the right thing, and the easier it is to know what tests to write.

You can't test everything, and real-world data is the best challenge any software can have. Testing in prod, and knowing when and what is breaking something is important. Monitoring, Logging and Alerting are the most important quality assurance you can have.

